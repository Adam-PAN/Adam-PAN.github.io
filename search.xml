<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《沉思录》读书报告]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[语言/翻译： &ensp; 7 / 10 思想/内核： &ensp; 8 / 10 知识含量： &ensp; 1 / 10 综合评分： &ensp; 5.33 / 10 &ensp; 一部不讲故事的新约，一部不参杂丝毫暴戾的古兰经，一部不含混的菜根谭，一部自省律己的孔孟论语。 &ensp; 其实该懂的都懂了，该想到的都想到了，过时的也都过时了；只不过想到当基督徒们还在口头传诵大爱，当穆罕默德还有400年才出生，一位皇帝却能在鞍马劳顿的十年里，拼死挽救没落古罗马的同时，开创自己的哲学殿堂，石饮心神的精神食粮，写出一部看似杂乱混散却立线鲜明的世界观大集，同时不停呼唤理智和理性，实在是难能可贵。 &ensp; 只不过，抛开那些不科学的，臆想的，和被时代淘汰了的，原来你个一手遮天征战沙场，睿智成熟斯多葛派的大皇帝，竟也这么怕死啊。嘿，天天用生死来逼自己，你不累吗？]]></content>
      <categories>
        <category>读书报告</category>
      </categories>
      <tags>
        <tag>读书报告</tag>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06/06 - 06/10 五日热点整理]]></title>
    <url>%2F2018%2F06%2F10%2F06-06-06-10-%E4%BA%94%E6%97%A5%E7%83%AD%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[G7峰会 最失败的一次G7峰会。 在俄罗斯与伊朗问题，联合贸易，进出口征税问题，气候问题上，美国依旧不与其他各国达成共识，没有任何进展；几国领导言语上冲突严重；全球范围内的贸易战一触即发。 快手1.7亿全资收购A站 快手以1.7亿元全盘收购A站，A站终于复活，结束了持续已久的股权纷争博弈。 A站的用户主要分布于一二线城市青少年群体，快手用户分布在三四五线城市的青年及以上年龄群体；从内容上看A站主打二次元内容，快手主打现实底层生活内容；从形式上看，A站属长视频平台，快手短视频平台。因此快手的收购不仅仅是A站的一根救命稻草，也从用户，内容与形式上全面弥补了快手的短板，极大扩大了生态链。 中兴正式与美签约解禁 10亿美元罚款，4亿美元保证金，换来为期10年的解禁。 两年又白干了。 中兴一事前后不到50天，其中的经贸博弈和核心技术禁锢，却是改革开放以来最经典的一课。 美国Summit成全球最快超算 美国能源部国家实验室公布Summit超算，实现每秒330亿亿次混合精度计算，成为最强大超算，打破了中国超算霸榜5年的局面]]></content>
      <categories>
        <category>五日热点整理</category>
      </categories>
      <tags>
        <tag>五日热点整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构轮子：2-栈之顺序栈的类实现]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AE%E5%AD%90%EF%BC%9A2-%E6%A0%88%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[栈的基类123456789101112131415#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class Stack&#123; public: Stack()&#123;&#125;; ~Stack()&#123;&#125;; virtual void Push(const T&amp; x)=0; virtual T Pop()=0; virtual T GetTop()=0; virtual bool IsEmpty()const =0; virtual int GetSize()const =0; virtual T GetSum()=0;&#125;; 顺序栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include"Stack"using namespace std;const int increaseSize = 20;const int defaultSize = 50;template &lt;class T&gt;class SeqStack: public Stack&lt;T&gt; &#123; private: T *data; int top; int maxSize; void OverFlowProcess(); public: SeqStack(int sz = defaultSize); ~SeqStack()&#123;delete []data;&#125; void Push(const T&amp; x); T Pop(); T GetTop(); bool IsEmpty()const&#123;return (top==-1)?true:false;&#125; int GetSize()const&#123;return (top+1);&#125; void Clear()&#123; top = -1; &#125; void Output(); T GetSum(); //friend ostream&amp; operator &lt;&lt; (ostream&amp; os, SeqStack&lt;T&gt;&amp; s);&#125;;template &lt;class T&gt;void SeqStack&lt;T&gt;::OverFlowProcess()&#123; maxSize+=increaseSize; T* ptr = new T[maxSize]; if(ptr==NULL)&#123; cout&lt;&lt;"err code:1"&lt;&lt;endl; exit(1); &#125; T *srcptr = data; T *desptr = ptr; int n = top+1; while(n--)&#123; *desptr = *srcptr; desptr++; srcptr++; &#125; delete []data; data = ptr;&#125;template&lt;class T&gt;SeqStack&lt;T&gt;::SeqStack(int sz)&#123; data = new T[sz]; maxSize = defaultSize; top = -1;&#125;template&lt;class T&gt;void SeqStack&lt;T&gt;::Push(const T&amp; x)&#123; if(top+1&gt;=maxSize) OverFlowProcess(); top++; data[top] = x;&#125;template&lt;class T&gt;T SeqStack&lt;T&gt;::Pop()&#123; if(IsEmpty()) cout&lt;&lt;"err code:2"&lt;&lt;endl; else&#123; top--; return data[top+1]; &#125; return 0;&#125;template&lt;class T&gt;T SeqStack&lt;T&gt;::GetTop()&#123; if(IsEmpty()) cout&lt;&lt;"err code:2"&lt;&lt;endl; else&#123; return data[top]; &#125; return 0;&#125;template&lt;class T&gt;void SeqStack&lt;T&gt;::Output()&#123; for(int i=0;i&lt;=top;i++) cout&lt;&lt;data[i]&lt;&lt;' '; cout&lt;&lt;endl;&#125;template&lt;class T&gt;T SeqStack&lt;T&gt;::GetSum()&#123; T sum=0; for(int i=0;i&lt;=top;i++) sum+=data[i]; return sum;&#125;/*template&lt;class T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, SeqStack&lt;T&gt;&amp; s)&#123; for(int i=0;i&lt;=s.top;i++) os&lt;&lt;s.data[i]&lt;&lt;' '; os&lt;&lt;endl; return os;&#125;*/ 函数说明12345678910111213141516171819202122232425//构造函数，构造时声明栈容量，默认容量为50 SeqStack(int sz = defaultSize);//析构函数，清空栈内存 ~SeqStack(); //向栈顶堆一个数据 void Push(const T&amp; x);//从栈顶溢出一个数据，并将它返回 T Pop();//返回栈顶的数据 T GetTop();//检查栈是否为空，空则返回true，非空则返回false bool IsEmpty()const;//返回栈中数据个数 int GetSize()const;//将栈清空 void Clear(); //栈溢出操作，每次增加20个空间，可无限扩展 void OverFlowProcess();//从栈底到栈顶输出栈中所有数据 void Output();//计算栈中所有数据的总和 T GetSum(); 报错信息121：调整栈容量出现错误2：栈已空，无法进行操作 总结 注意！为类内函数内元素赋默认值时，要在声明时赋值，并在之后无论类内类外的描述中都不需要赋值。该bug调了近一个小时。。。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>顺序栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构轮子：1.线性表之顺序表的类实现]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AE%E5%AD%90%EF%BC%9A1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[线性表的基类1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std; template &lt;class T&gt; class LinearList&#123; public: LinearList()&#123;&#125;; ~LinearList()&#123;&#125;; virtual int Size()const=0; virtual int Length()const=0; virtual int Search(T&amp; x)const=0; virtual T GetData(int i)const=0; virtual bool SetData(int i, T&amp; x)=0; virtual bool Insert(int i, T&amp; x)=0; virtual bool Remove(int i)=0; virtual bool IsEmpty()const=0; virtual bool IsFull()const=0; virtual void Sort()=0; virtual void Input(int size)=0; virtual void Output()=0; virtual T Sum()=0; &#125;; 顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include&lt;iostream&gt;#include&lt;algorithm&gt;#include"LinearList"using namespace std; template &lt;class T&gt; class SeqList:public LinearList&lt;T&gt;&#123; protected: T *data; int maxSize; int last; void ReSize(int newSize); public: SeqList(int); //SeqList(int sz):data(new T[sz]),maxSize(sz),last(-1)&#123;&#125; SeqList(const SeqList&lt;T&gt;&amp; L); ~SeqList()&#123;delete []data;&#125; int Size()const; int Length()const; int Search(T&amp; x)const; T GetData(int i)const; bool SetData(int i, T&amp; x); bool Insert(int i, T&amp; x); bool Remove(int i); bool IsEmpty()const; bool IsFull()const; void Sort(); void Reverse(); void Input(int size); void Output(); T Sum(); SeqList&lt;T&gt;&amp; operator = (SeqList&lt;T&gt;&amp; L); &#125;; template &lt;class T&gt; SeqList&lt;T&gt;::SeqList(int sz)&#123; data = new T[sz]; maxSize = sz; last = -1; &#125; template &lt;class T&gt; SeqList&lt;T&gt;::SeqList(const SeqList&lt;T&gt;&amp; L)&#123; maxSize = L.maxSize; last = L.last; data = new T[maxSize]; if(data==NULL)&#123; cout&lt;&lt;"err code:0"&lt;&lt;endl; exit(1); &#125; T value; for(int i=1;i&lt;=last+1;i++)&#123; value = L.GetData(i); SetData(i,value); &#125; &#125; template &lt;class T&gt; void SeqList&lt;T&gt;::ReSize(int newSize)&#123; if(newSize&lt;=0)&#123; cout&lt;&lt;"err code:1"&lt;&lt;endl; exit(1); &#125; if(newSize != maxSize)&#123; maxSize = newSize; T* ptr = new T[maxSize]; if(ptr==NULL)&#123; cout&lt;&lt;"err code:1"&lt;&lt;endl; exit(1); &#125; T*srcptr = data; T*desptr = ptr; int n = last+1; while(n--) *desptr++ = *srcptr++; delete []data; data = ptr; &#125; &#125; template&lt;class T&gt; int SeqList&lt;T&gt;::Size()const&#123; return maxSize; &#125; template&lt;class T&gt; int SeqList&lt;T&gt;::Length()const&#123; return last+1; &#125; template&lt;class T&gt; int SeqList&lt;T&gt;::Search(T&amp; x)const&#123; for(int i=0;i&lt;=last;i++) if(data[i]==x) return i+1; return -1; &#125; template&lt;class T&gt; T SeqList&lt;T&gt;::GetData(int i)const&#123; if(i&gt;=1&amp;&amp;i&lt;=last+1) return data[i-1]; else cout&lt;&lt;"err code:2"&lt;&lt;endl; &#125; template&lt;class T&gt;bool SeqList&lt;T&gt;::SetData(int i, T&amp; x)&#123; if(i&gt;=1&amp;&amp;i&lt;=last+2) data[i-1]=x; else&#123; cout&lt;&lt;"err code:3"&lt;&lt;endl; return false; &#125; return true;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::Insert(int i, T&amp; x)&#123; if(i&lt;=0||i&gt;last+2||IsFull()) return false; for(int j=last+1;j&gt;=i;j--) data[j+1]=data[j]; data[i]=x; last++; return true;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::Remove(int i)&#123; if(i&lt;=0||i&gt;last+1) return false; else&#123; for(int j=i;j&lt;=last;j++) data[j-1]=data[j]; last--; &#125; return true;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::IsFull()const&#123; if(last&lt;maxSize-1) return false; else return true;&#125;template&lt;class T&gt;bool SeqList&lt;T&gt;::IsEmpty()const&#123; if(last&gt;-1) return false; else return true;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::Sort()&#123; sort(data,data+last+1);&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::Reverse()&#123; sort(data,data+last+1); T temp; for(int i=0,j=last;i!=j;i++,j--)&#123; temp = data[i]; data[i] = data[j]; data[j] = temp; &#125;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::Input(int size)&#123; if(size&gt;maxSize-1-last) cout&lt;&lt;"err code:4"&lt;&lt;endl; else&#123; for(int i=last+1;i&lt;=last+size;i++) cin&gt;&gt;data[i]; last+=size; &#125;&#125;template&lt;class T&gt;void SeqList&lt;T&gt;::Output()&#123; for(int i=0;i&lt;=last;i++) cout&lt;&lt;data[i]&lt;&lt;' '; cout&lt;&lt;endl;&#125;template&lt;class T&gt;T SeqList&lt;T&gt;::Sum()&#123; T sum=0; for(int i=0;i&lt;=last;i++) sum+=data[i]; return sum; &#125;template&lt;class T&gt; SeqList&lt;T&gt;&amp; SeqList&lt;T&gt;::operator = (SeqList&lt;T&gt;&amp; L) &#123; maxSize=L.maxSize; last=L.last; data=new T[maxSize]; if(data==NULL)&#123; //cout&lt;&lt;"err code:5"&lt;&lt;endl; exit(1); &#125; T value; for(int i=1;i&lt;=last+1;i++)&#123; value=L.GetData(i); SetData(i,value); &#125; return *this; &#125; 函数说明1234567891011121314151617181920212223242526272829303132333435363738394041//构造函数，构造时声明表容量 SeqList(int);//拷贝构造函数 SeqList(const SeqList&lt;T&gt;&amp; L);//析构函数，清空表内存 ~SeqList()&#123;delete []data;&#125; //检查表的容量，返回int型容量大小 int Size()const;//检查已存储的数据长度，返回int型长度 int Length()const;//查找表中x值所在位置，返回int型表项序号，若无x则返回-1 int Search(T&amp; x)const;//取得第i个表项的值，若未取得则报错 T GetData(int i)const;//将第i个表项的值改为x，修改成功返回true，修改失败返回false并报错 bool SetData(int i, T&amp; x);//在第i个表项位置插入一个x，成功插入返回true，否则返回false bool Insert(int i, T&amp; x);//清除第i个数据，成功返回true，失败返回false bool Remove(int i);//判断表是否为空，空则返回true，不空返回false bool IsEmpty()const;//判断表是否已满，满则返回true，不满返回false bool IsFull()const;//将表以从小到大顺序排序 void Sort();//将表以从大到小顺序排序 void Reverse();//输入size个数据，在表后依次添加 void Input(int size);//输出表中所有数据 void Output();//将表中所有数据加和，并返回总和 T Sum();//保护函数，调整表容量为newSize void ReSize(int newSize); //重载运算符“=”，完成表间拷贝 SeqList&lt;T&gt;&amp; operator = (SeqList&lt;T&gt;&amp; L); 报错信息123451： 调整表容量出现错误2： 取第i项值时出现错误3： 为第i项赋值时出现错误4： 在表后添加数据出现错误//5： 表间拷贝出现错误 总结 C++细节遗忘的太多了，以及一直没有像样的写过工程系代码，很不熟练，半数面向代码编程。 注意！所有基类的虚函数必须严格实函数化才能运行！该bug调试了一个多小时。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>顺序表</tag>
        <tag>线性表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《指尖世界 移动App界面设计之道》读书报告]]></title>
    <url>%2F2018%2F06%2F06%2F%E3%80%8A%E6%8C%87%E5%B0%96%E4%B8%96%E7%95%8C-%E7%A7%BB%E5%8A%A8App%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[语言/翻译： &ensp; 5 / 10 思想/内核： &ensp; 4 / 10 知识含量： &ensp; 4 / 10 综合评分： &ensp; 4.67 / 10 &ensp; 以一个专业UI设计师的角度阐述自己的工作内容，从思维表述到用户体验再到各种职场必备的能力，东拼西凑了一幅理想UI设计人员的速写。语言赘碎，爱讲大道理，知识与思想可以压缩成10页。 艺术设计与工业设计往往不能同时处理，要分别以艺术和产品的角度审视，反复博弈后进行决策，不能同时做视觉设计和交互设计。 设计元素做到规范与合理化，主要包括： 规范的用户调研，权衡红花与绿叶的关系，遵循眼动原则，文字排版样式细节的一致性，颜色避免过分撞色，构图紧凑一致。 确定用户需求并编写文档进行讲解时首先注意故事性，其次才是逻辑性。 流行元素的运用紧跟大厂，是扁平化，像素化还是写实化，随大厂的潮流引领，容错率最大，可行性最高。 任何一件以用户体验为原则的实体优化都可以类推用于app界面上。]]></content>
      <categories>
        <category>读书报告</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>App</tag>
        <tag>读书报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06/01-06/05 五日热点整理]]></title>
    <url>%2F2018%2F06%2F05%2F06-01-06-05-%E4%BA%94%E6%97%A5%E7%83%AD%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[今日头条战腾讯 &ensp; &ensp; &ensp; 今日头条以9000w赔偿金的起诉回应腾讯1元赔偿起诉。 &ensp; &ensp; &ensp; 头条表面上争夺短视频信息流量，实际尝试从内容跨越到通讯社交，进而发展商业模式，抢夺腾讯地盘；另一方面，今日头条逐渐向阿里靠拢，一改从前不站队不拿巨头投资的风格，可以说，中国互联网之争，最终还是会落回到AT的封锁负和博弈。个人预测头条将在短期内全面封锁腾讯链，尝试推出头条系社交软件与购物渠道，但最终不温不火以失败和解告终。 &ensp; &ensp; &ensp; 同时，以B站为首的前互联网黑马受关注度骤减，个人预测B站以一贯高冷的风格，将在半年内尝试推出新内容新平台，但为时已晚。当无广告的长视频内容成为流量焦点时，B站未能继续创新引领内容潮流，而是不痛不痒得修改界面，推出大会员，继续推广动画业务，捡了用户体验的芝麻，丢了内容革新的西瓜，最终会成为下一个A站。 &ensp; &ensp; &ensp; 另一方面，如果今日头条继续稳步发展，可能会涉足音乐产业。抖音视频的诱人之处便在于用户精心挑选，剪辑的15秒配乐。从乔布斯通过iTunes涉足音乐产业，电台点歌，节目爆款，到今天大陆网民熟用的网易qq音乐所形成的新音乐消费观，音乐产业离不开现象级的热度和付费前的试听；然而音乐渠道十分稀少，30秒的前奏试听又难以表达一些表现形式的歌曲，这就造成了小众音乐火不成，小音乐人活不了的现状。抖音很好的改善了这一现象，从前段时间的小众音乐《心愿便利贴》《离人愁》，小音乐团体 “音阙诗听” “新乐尘符”，到最近红到发紫的《答案》及其翻唱者，有太多的人听完便去音乐平台搜索，不仅激励了音乐人的创作热情，也提高了听众的审美标准。个人预测如果头条继续与腾讯作对，很有可能向网易投出橄榄枝。 美朝会晤&ensp; &ensp; &ensp; 特朗普确定将于12日与金正恩会晤。 《西瓜足迹》小程序爆红 &ensp; &ensp; &ensp; 完全抄袭5个月前运营的小程序《脚步地图》，依靠虚假的“超越%用户”激发炫耀心理爆红，一天上线访问量达到1000万次。 &ensp; &ensp; &ensp; 制作壁垒低，用户留存量低，隐私数据是否被利用，原创者如何维权等，依然是当前爆红小程序的焦点。 微软收购Github &ensp; &ensp; &ensp; 此举或结束了 Github 9年找不到CEO且不盈利的状态，尽管业内普遍不看好，并引发了开发者信任等问题，但也看出微软在向开源拥抱，希望微软能够维持 Github 的理念并真正做到给开发者赋能。 &ensp; &ensp; &ensp; 在宣布收购的同时，Gitlab 项目输入增加了10倍，个人认为只是小浪潮。 苹果WWDC发布会 &ensp; &ensp; &ensp; 没有任何硬件上的更新；ios12系统更新很大，可以说人机交互更流畅了；软件上实用的部分紧跟安卓，不跟安卓的又不够实用，很多安卓P悄悄更新不声张的东西，苹果却拿来当作重点；与Adobe合作开发AR专用格式USDZ，个人对不兼容特殊格式向来不看好。 &ensp; &ensp; &ensp; ​不难看出，苹果的创新能力已经严重下滑了，封闭的生态环境导致开发者们只能单纯等待苹果跟随安卓的步伐。当然如此低效的更新却又要嘲讽下安卓的更新成效，一个负重淌水，一个摸石头过河造桥，难免有些说葡萄酸的味道。]]></content>
      <categories>
        <category>五日热点整理</category>
      </categories>
      <tags>
        <tag>五日热点整理</tag>
      </tags>
  </entry>
</search>
